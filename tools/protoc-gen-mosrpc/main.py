#!/usr/bin/env python

import logging
import subprocess
import sys

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.descriptor_pb2 import FileDescriptorProto


logging.basicConfig(level=logging.WARN, format="%(asctime)s - %(levelname)s - %(message)s")


def camelcase_to_underscore(name: str) -> str:
    return "".join(
        ["_" + c.lower() if c.isupper() else c for c in name]
    ).lstrip("_")


def camelcase_to_full_uppercase(name: str) -> str:
    return "".join(
        ["_" + c.upper() if c.isupper() else c for c in name]
    ).lstrip("_").upper()


def resolve_protobuf_typename(type_name: str) -> str:
    if type_name.startswith("."):
        type_name = type_name[1:]
    return type_name.replace(".", "_")


def process_file(proto_file: FileDescriptorProto, response: plugin.CodeGeneratorResponse) -> None:
    if not proto_file.service:
        return

    file_content = ""

    def write(content: str = "") -> None:
        nonlocal file_content
        file_content += content + "\n"

    module_name = proto_file.name.replace(".proto", "")

    write("// SPDX-License-Identifier: GPL-3.0-or-later")
    write("// !! AUTOGENERATED FILE !!")
    write("// This file is generated by protoc-gen-mosrpc, do not edit.")
    write("// Any changes made to this file will be lost.")
    write("")
    write(f"// generated when processing {module_name}.proto")
    write("")
    write("#pragma once")
    write("")

    for dependency in proto_file.dependency:
        if dependency == 'nanopb.proto':
            continue
        dep_module_name = dependency.replace('.proto', '')
        write(f'#include "proto/{dep_module_name}.pb.h"')

    write(f'#include "proto/{module_name}.pb.h"')

    if proto_file.dependency:
        write("")

    for service in proto_file.service:
        write(f'// {service.name} service')
        write(f'#define {service.name.upper()}_SERVICE_X(ARGS, PB, xarg) \\')
        for mid, method in enumerate(service.method):
            rpc_name = camelcase_to_underscore(method.name)
            rpc_upper = camelcase_to_full_uppercase(method.name)
            write(f'    PB(xarg, {mid + 1}, {rpc_name}, {rpc_upper}, {resolve_protobuf_typename(method.input_type)}, {resolve_protobuf_typename(method.output_type)}) \\')
        write(f'    /**/')

    # check if clang-format is available
    if not subprocess.run(["which", "clang-format"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).returncode == 0:
        logging.warning("clang-format not found, skipping formatting")
    else:
        # launch clang-format on the file content
        file_content = subprocess.run(
            ["clang-format"],
            input=file_content.encode("utf-8"),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        ).stdout.decode("utf-8")

    logging.info(f"Generated {module_name}.services.h")
    file = response.file.add()
    file.name = module_name + ".services.h"
    file.content = file_content


if __name__ == "__main__":
    request = plugin.CodeGeneratorRequest.FromString(sys.stdin.buffer.read())
    response = plugin.CodeGeneratorResponse()

    for file in request.proto_file:
        process_file(file, response)

    # Serialize response and write to stdout
    sys.stdout.buffer.write(response.SerializeToString())
