#!/usr/bin/env python

import logging
import subprocess
import sys

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.descriptor_pb2 import FileDescriptorProto


logging.basicConfig(level=logging.WARN, format="%(asctime)s - %(levelname)s - %(message)s")

FILE_PREAMBLE = f"""// SPDX-License-Identifier: GPL-3.0-or-later
// !! AUTOGENERATED FILE !!
// This file is generated by protoc-gen-mosrpc, do not edit.
// Any changes made to this file will be lost.

#pragma once

#if !defined(__MOS_KERNEL__) && defined(__cplusplus) && defined(__MOS_RPC_SERVER__)
#define __rpc_have_server__
#endif

#if !defined(__MOS_KERNEL__) && defined(__cplusplus) && defined(__MOS_RPC_CLIENT__)
#define __rpc_have_client__
#endif

// don't expose this to the kernel
#ifdef __rpc_have_server__
#include <librpc/rpc_server++.hpp>
#endif

#ifdef __rpc_have_client__
#include <string>  // HACK
#include <librpc/rpc_client.h>
#endif
"""


def camelcase_to_underscore(name: str) -> str:
    return "".join(
        ["_" + c.lower() if c.isupper() else c for c in name]
    ).lstrip("_")


def camelcase_to_full_uppercase(name: str) -> str:
    return "".join(
        ["_" + c.upper() if c.isupper() else c for c in name]
    ).lstrip("_").upper()


def resolve_protobuf_typename(type_name: str) -> str:
    if type_name.startswith("."):
        type_name = type_name[1:]
    return type_name.replace(".", "_")


def process_file(proto_file: FileDescriptorProto, response: plugin.CodeGeneratorResponse) -> None:
    if not proto_file.service:
        return

    file_content = ""

    def write(content: str = "") -> None:
        nonlocal file_content
        file_content += content + "\n"

    module_name = proto_file.name.replace(".proto", "")

    write(FILE_PREAMBLE)
    write(f'#include "proto/{module_name}.pb.h"')
    write(f'')

    for service in proto_file.service:
        write(f'// {service.name} service')
        write(f'#define {service.name.upper()}_SERVICE_X(ARGS, PB, xarg) \\')
        for mid, method in enumerate(service.method):
            rpc_name = camelcase_to_underscore(method.name)
            rpc_upper = camelcase_to_full_uppercase(method.name)
            input_type = resolve_protobuf_typename(method.input_type)
            output_type = resolve_protobuf_typename(method.output_type)
            write(f'    PB(xarg, {mid + 1}, {rpc_name}, {rpc_upper}, {input_type}, {output_type}) \\')
        write(f'    /**/')
        write(f'')

    write(f"// Service stubs and interfaces for C++ clients and servers")
    write(f'#ifdef __rpc_have_client__')
    for service in proto_file.service:
        x_macro_name = f'{service.name.upper()}_SERVICE_X'
        write(f'RPC_CLIENT_DEFINE_STUB_CLASS({service.name}Stub, {x_macro_name});')
    write(f'#endif')

    write(f'')

    write(f'#ifdef __rpc_have_server__')
    for service in proto_file.service:
        x_macro_name = f'{service.name.upper()}_SERVICE_X'
        write(f'RPC_DECL_SERVER_INTERFACE_CLASS(I{service.name}Service, {x_macro_name});')
    write(f'#endif')
    write(f'')

    write(f'#undef __rpc_have_server__')
    write(f'#undef __rpc_have_client__')

    # check if clang-format is available
    if not subprocess.run(["which", "clang-format"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).returncode == 0:
        logging.warning("clang-format not found, skipping formatting")
    else:
        # launch clang-format on the file content
        file_content = subprocess.run(
            ["clang-format"],
            input=file_content.encode("utf-8"),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        ).stdout.decode("utf-8")

    logging.info(f"Generated {module_name}.services.h")
    file = response.file.add()
    file.name = module_name + ".services.h"
    file.content = file_content


if __name__ == "__main__":
    request = plugin.CodeGeneratorRequest.FromString(sys.stdin.buffer.read())
    response = plugin.CodeGeneratorResponse()

    for file in request.proto_file:
        process_file(file, response)

    # Serialize response and write to stdout
    sys.stdout.buffer.write(response.SerializeToString())
